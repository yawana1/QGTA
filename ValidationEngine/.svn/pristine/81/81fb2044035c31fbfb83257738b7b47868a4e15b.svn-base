package validation;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math.stat.correlation.PearsonsCorrelation;
import org.apache.log4j.Logger;

import asreml.output.AsrVariance;
import data.xml.objects.App;

import data.Model;
import data.Report;
import data.Trait;
import data.Trial;
import io.ReportDirectorySimpleFileVisitor;
import io.ReportWriter;
import io.WorkDirectorySimpleFileVisitor;

public class Validator {
	
	static Logger objLogger = Logger.getLogger(Validator.class.getName());
	private String[] strArrayPrimaryModelNames;
	private WorkDirectorySimpleFileVisitor objWorkDirectorySimpleFileVisitor;
	private List<Trial> lstTrials;
	private ReportDirectorySimpleFileVisitor objReportDirectorySimpleFileVisitor;
	private List<Report> lstCurrentReports;
	private List<Report> lstPreviousReports;	
	private TreeMap<String, List<Trial>> treMapTrialsByTrait;
	private ReportWriter objReportWriter;
	private DateFormat objDataFormat;
	
	public Validator(String[] strInArrayPrimaryModelNames) {		
		this.strArrayPrimaryModelNames = strInArrayPrimaryModelNames;
	}
	
	public void run() {
		try {
			this.coverWorkDirectory();
			this.coverReportDirectory();
			this.getTrialsByTrait();
			this.processTraits();
		}
		catch (IOException e) {
			objLogger.error("Validator.run", 
                            e);
		}
	}

	private void coverWorkDirectory() throws IOException {
		int intPrimaryModelsNumber;
		
		try {
			this.objWorkDirectorySimpleFileVisitor = new WorkDirectorySimpleFileVisitor();
		}
		catch (Exception e) {
			objLogger.error("Validator.coverWorkDirectory", 
                            e);
		}
		Files.walkFileTree(Paths.get(App.INSTANCE.getWorkDirectory()), 
				           this.objWorkDirectorySimpleFileVisitor);
		this.lstTrials = this.objWorkDirectorySimpleFileVisitor.getTrials();
		
		////////////////////////////////////////////////////////////
		// Checks the uniqueness of a primary model for each trial  
		////////////////////////////////////////////////////////////
		for (Trial objTrial : this.lstTrials) {
			intPrimaryModelsNumber = 0;
			for (Model objModel : objTrial.getModels()) {
				if (this.checkModelNameAsPrimary(objModel.getName())) {
					intPrimaryModelsNumber = intPrimaryModelsNumber + 1;
				}
			}
			if (intPrimaryModelsNumber == 0) {
				throw new RuntimeException("The trial, " + objTrial.getName() + ", does not have any primary model");
			}
			else {
				if (intPrimaryModelsNumber != 1) {
					throw new RuntimeException("The trial, " + objTrial.getName() + ", has more than one primary model");
				}
			}
		}
		
		this.getAsrData();
	}

	private void getAsrData() {
		int intTrialIndex;
		int intModelIndex;
		int intTraitIndex;
		Path objAsrFilePath;
		asreml.Trait objAsremlTrait;
		List<asreml.Trait> lstArsemlTraits;
		asreml.output.AsrData objAsrData;
		Map<String,AsrVariance> objAsrVariancesMap;
		boolean bolBoundedVCs;
		
		for (Trial objTrial : this.lstTrials) {
			intTrialIndex = this.lstTrials.indexOf(objTrial);
			for (Model objModel : objTrial.getModels()) {
				intModelIndex = this.lstTrials.get(intTrialIndex).getModels().indexOf(objModel);
				for (Trait objTrait : objModel.getTraits()) {
					intTraitIndex = this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits().indexOf(objTrait);
					///////////////////////////////////////////////////////////////////////////////////////////////
					// The AsrData class in the Trial Analysis project adds the extension ".asr" to any filename,   
					// even having the same extension!
					///////////////////////////////////////////////////////////////////////////////////////////////					
					objAsrFilePath = FileSystems.getDefault().getPath(objTrait.getPath().toString(), "asreml");
					objAsremlTrait = new asreml.Trait(objTrait.getName(), 
							                          0);
					lstArsemlTraits = new ArrayList<asreml.Trait>();
                    lstArsemlTraits.add(objAsremlTrait);
					objAsrData = new asreml.output.AsrData(objAsrFilePath,
					                                       0,
					                                       0,
					                                       0,
					                                       lstArsemlTraits,
											               0.0);
					this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits().get(intTraitIndex).setConverged(objAsrData.isConverged());
					objAsrVariancesMap = objAsrData.getVariance(objAsremlTrait);
					if (objAsrVariancesMap.get("Variance") != null) {
						bolBoundedVCs = this.getBoundedC(objAsrVariancesMap.get("Variance").getC());
					}
					else {
						bolBoundedVCs = false;
					}
					this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits().get(intTraitIndex).setBoundedVCs(bolBoundedVCs);
				}
			}
		}
	}
	
	private void coverReportDirectory() throws IOException,
    										   FileNotFoundException {
		try {
			this.objReportDirectorySimpleFileVisitor = new ReportDirectorySimpleFileVisitor();
		}
		catch (Exception e) {
			objLogger.error("Validator.coverReportDirectory", 
							e);
		}
		Files.walkFileTree(Paths.get(App.INSTANCE.getReportDirectory()), 
						   this.objReportDirectorySimpleFileVisitor);
		this.lstCurrentReports = this.objReportDirectorySimpleFileVisitor.getCurrentReports();
		this.lstPreviousReports = this.objReportDirectorySimpleFileVisitor.getPreviousReports();		
	}
	
	private void getTrialsByTrait() {
		List<Trial> lstTrials;
		
		this.treMapTrialsByTrait = new TreeMap<String, List<Trial>>();
		for (Trial objTrial : this.lstTrials) {
			for (Model objModel : objTrial.getModels()) {
				for (Trait objTrait : objModel.getTraits()) { 
					if (!(this.treMapTrialsByTrait.containsKey(objTrait.getName()))) {
						lstTrials = new ArrayList<Trial>();
						lstTrials.add(objTrial);
						this.treMapTrialsByTrait.put(objTrait.getName(), 
								                     lstTrials);
					}
					else {
						if (!(this.treMapTrialsByTrait.get(objTrait.getName()).contains(objTrial))) {
							this.treMapTrialsByTrait.get(objTrait.getName()).add(objTrial);
						}
					}
				}
			}
		}
		try {
			if (this.treMapTrialsByTrait.isEmpty()) {
				throw new Exception("No useful trial data for the traits");
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			objLogger.error("Validator.getTrialsByTrait", 
							e);
			throw new RuntimeException();
		}
	}
	
	private void processTraits() {
		String[] strArrayHeaders;
		Iterator<Map.Entry<String, List<Trial>>> iteTrialsByTrait;
		Map.Entry<String, List<Trial>> objMapEntry;
		String strTraitName;
		int intChosenTrialsNumber;
		Report objReport;
		int intPreviousReportIndex;
		int intCurrentReportIndex;
		Object[] objArrayRowData;
		int intPreviousLocationsNumber;
		int intCurrentLocationsNumber;
		int intPreviousRecordsNumber;
		int intCurrentRecordsNumber;		
		int intTrialIndex;
		int intModelIndex;
		boolean bolAllModelsConverged;
		Map<Integer, Double> mapIntegerKeyedX; 
		Map<Integer, Double> mapIntegerKeyedY;
		Map<String, Double> mapStringKeyedX; 
		Map<String, Double> mapStringKeyedY;
		List<Double> lstX;
		List<Double> lstY;	
		double[] douArrayX;
	    double[] douArrayY;
		
		strArrayHeaders = new String[12];
		strArrayHeaders[ 0] = "Trial Name";
		strArrayHeaders[ 1] = "Locations Number";
		strArrayHeaders[ 2] = "Deviation of Locations Numbers";
		strArrayHeaders[ 3]	= "Genotypes Number"; 	
		strArrayHeaders[ 4] = "Deviation of Genotypes Numbers";
		strArrayHeaders[ 5] = "Total rawCounts";
		strArrayHeaders[ 6] = "All Converge";
		strArrayHeaders[ 7] = "Primary Model Converge";
		strArrayHeaders[ 8] = "Bounded VCs";
		strArrayHeaders[ 9] = "Correlation Of estimate (entrySummary)";
		strArrayHeaders[10] = "Correlation Of rawMean (exlSummary)";
		strArrayHeaders[11] = "Correlation Of estimate (locationSummary)";		
		
		this.objReportWriter = new ReportWriter();
		this.objDataFormat = new SimpleDateFormat("MM_dd_yyyy_HH_mm_ss");
		iteTrialsByTrait = this.treMapTrialsByTrait.entrySet().iterator();
		while (iteTrialsByTrait.hasNext())
		{
			objMapEntry = (Map.Entry<String, List<Trial>>)iteTrialsByTrait.next();
			strTraitName = objMapEntry.getKey();
			this.objReportWriter.createSheet(strTraitName,
					                         strArrayHeaders);
			intChosenTrialsNumber = 0;
			for (Trial objTrial : objMapEntry.getValue()) {
				objReport = new Report(objTrial.getName());
				intPreviousReportIndex = this.lstPreviousReports.indexOf(objReport);
				intCurrentReportIndex = this.lstCurrentReports.indexOf(objReport);
				if ((intPreviousReportIndex != -1) && 
				    (intCurrentReportIndex != -1)) {
					if ((this.lstPreviousReports.get(intPreviousReportIndex).getLocationsNumbers().containsKey(strTraitName)) &&
						(this.lstCurrentReports.get(intCurrentReportIndex).getLocationsNumbers().containsKey(strTraitName)) &&	
						(this.lstPreviousReports.get(intPreviousReportIndex).getRecordsNumbers().containsKey(strTraitName)) && 
						(this.lstCurrentReports.get(intCurrentReportIndex).getRecordsNumbers().containsKey(strTraitName))) {
						intChosenTrialsNumber = intChosenTrialsNumber + 1;
					}
				}
			}
			if (intChosenTrialsNumber == 0) {
				System.out.println("No trial data useful for the trait: " + strTraitName);
			}
			else {
				System.out.println("Generating trial data useful for the trait: " + strTraitName);
				for (Trial objTrial : objMapEntry.getValue()) {
					objArrayRowData = new Object[strArrayHeaders.length];
					
					////////////////////////////
					// The column "Trial name"  
					////////////////////////////
					objArrayRowData[ 0] = objTrial.getName(); 

					objReport = new Report(objTrial.getName());
					intCurrentReportIndex = this.lstCurrentReports.indexOf(objReport);
					intPreviousReportIndex = this.lstPreviousReports.indexOf(objReport);
					if (intCurrentReportIndex != -1) {
						if (this.lstCurrentReports.get(intCurrentReportIndex).getLocationsNumbers().containsKey(strTraitName)) {
							intCurrentLocationsNumber = this.lstCurrentReports.get(intCurrentReportIndex).getLocationsNumbers().get(strTraitName);
							intCurrentRecordsNumber = this.lstCurrentReports.get(intCurrentReportIndex).getRecordsNumbers().get(strTraitName);
							//////////////////////////////////////////////////////////
							// The columns "Locations Number" and "Genotypes Number"  
							//////////////////////////////////////////////////////////
							objArrayRowData[ 1] = intCurrentLocationsNumber;
							objArrayRowData[ 3] = intCurrentRecordsNumber;
							if (intPreviousReportIndex != -1) {
								if (this.lstPreviousReports.get(intPreviousReportIndex).getLocationsNumbers().containsKey(strTraitName)) {
									intPreviousLocationsNumber = this.lstPreviousReports.get(intPreviousReportIndex).getLocationsNumbers().get(strTraitName);
									intPreviousRecordsNumber = this.lstPreviousReports.get(intPreviousReportIndex).getRecordsNumbers().get(strTraitName);
									//////////////////////////////////////////////////////////////////////  
									// The columns "Deviation of #locations" and "Deviation of #records"  
									//////////////////////////////////////////////////////////////////////
									objArrayRowData[ 2] = intCurrentLocationsNumber - intPreviousLocationsNumber;
									objArrayRowData[ 4] = intCurrentRecordsNumber - intPreviousRecordsNumber;
								}
							}
						}
						if (this.lstCurrentReports.get(intCurrentReportIndex).getRawCounts().containsKey(strTraitName)) {
							/////////////////////////////////
							// The column "Total rawCounts"  
							/////////////////////////////////
							objArrayRowData[5] = this.lstCurrentReports.get(intCurrentReportIndex).getRawCounts().get(strTraitName);
						}
					}
					
					//////////////////////////////
					// The column "All Converge"  
					//////////////////////////////
					intTrialIndex = this.lstTrials.indexOf(objTrial);
					bolAllModelsConverged = true;
					for (Model objModel : this.lstTrials.get(intTrialIndex).getModels()) {
						intModelIndex = this.lstTrials.get(intTrialIndex).getModels().indexOf(objModel);
						for (Trait objTrait : this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits()) {
							if (objTrait.getName().equals(objMapEntry.getKey())) {
								bolAllModelsConverged = bolAllModelsConverged && objTrait.getConverged();   
							}
						}
					}
					objArrayRowData[6] = this.translateBooleanValue(bolAllModelsConverged);
				
					/////////////////////////////////////////////////////
					// The columns "Primary Model" and "Bounded VCs"  
				    /////////////////////////////////////////////////////
					for (Model objModel : this.lstTrials.get(intTrialIndex).getModels()) {
						if (this.checkModelNameAsPrimary(objModel.getName())) {
							intModelIndex = this.lstTrials.get(intTrialIndex).getModels().indexOf(objModel);
							for (Trait objTrait : this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits()) {
								if (objTrait.getName().equals(objMapEntry.getKey())) {
									objArrayRowData[ 7] = this.translateBooleanValue(objTrait.getConverged());
									objArrayRowData[ 8] = this.translateBooleanValue(objTrait.getBoundedVCs());									
									break;
								}
							}
							break;
						}
					}

					if ((intCurrentReportIndex != -1) && 
						(intPreviousReportIndex != -1)) {
						////////////////////////////////////////////////////////
						// The column "Correlation Of estimate (entrySummary)"   
						////////////////////////////////////////////////////////
						mapIntegerKeyedX = this.lstCurrentReports.get(intCurrentReportIndex).getEntryEstimates().get(strTraitName);
						mapIntegerKeyedY = this.lstPreviousReports.get(intPreviousReportIndex).getEntryEstimates().get(strTraitName);
						if ((mapIntegerKeyedX != null) && 
						    (mapIntegerKeyedY != null))
						{
							lstX = new ArrayList<Double>();
							lstY = new ArrayList<Double>();
							for (Integer intKey : mapIntegerKeyedX.keySet()) {
								if (mapIntegerKeyedY.containsKey(intKey)) {
									lstX.add(mapIntegerKeyedX.get(intKey));
									lstY.add(mapIntegerKeyedY.get(intKey));
								}
							}
							if (1 < lstX.size()) {
								douArrayX = ArrayUtils.toPrimitive(lstX.toArray(new Double[lstX.size()]));
								douArrayY = ArrayUtils.toPrimitive(lstY.toArray(new Double[lstY.size()]));
								objArrayRowData[ 9] = this.getPearsonProductMomentCorrelationCoefficient(douArrayX, 
                                                                                                     	 douArrayY);
							}
							else {
								objArrayRowData[ 9] = "";
							}
						}
						else {
							objArrayRowData[ 9] = "";
						}
					
						/////////////////////////////////////////////////////
						// The column "Correlation Of rawMean (exlSummary)"   
						/////////////////////////////////////////////////////
						mapStringKeyedX = this.lstCurrentReports.get(intCurrentReportIndex).getExlRawMeans().get(strTraitName);
						mapStringKeyedY = this.lstPreviousReports.get(intPreviousReportIndex).getExlRawMeans().get(strTraitName);
						if ((mapStringKeyedX != null) && 
							(mapStringKeyedY != null))
						{
							lstX = new ArrayList<Double>();
							lstY = new ArrayList<Double>();
							for (String strKey : mapStringKeyedX.keySet()) {
								if (mapStringKeyedY.containsKey(strKey)) {
									lstX.add(mapStringKeyedX.get(strKey));
									lstY.add(mapStringKeyedY.get(strKey));
								}
							}
							if (1 < lstX.size()) {
								douArrayX = ArrayUtils.toPrimitive(lstX.toArray(new Double[lstX.size()]));
								douArrayY = ArrayUtils.toPrimitive(lstY.toArray(new Double[lstY.size()]));
								objArrayRowData[10] = this.getPearsonProductMomentCorrelationCoefficient(douArrayX, 
                                                                                                     	 douArrayY);
							}
							else {
								objArrayRowData[10] = "";
							}
						}
						else {
							objArrayRowData[10] = "";
						}
							
						///////////////////////////////////////////////////////////
						// The column "Correlation Of estimate (locationSummary)"   
						///////////////////////////////////////////////////////////
						mapIntegerKeyedX = this.lstCurrentReports.get(intCurrentReportIndex).getLocationEstimates().get(strTraitName);
						mapIntegerKeyedY = this.lstPreviousReports.get(intPreviousReportIndex).getLocationEstimates().get(strTraitName);
						if ((mapIntegerKeyedX != null) && 
							(mapIntegerKeyedY != null))
						{
							lstX = new ArrayList<Double>();
							lstY = new ArrayList<Double>();
							for (Integer intKey : mapIntegerKeyedX.keySet()) {
								if (mapIntegerKeyedY.containsKey(intKey)) {
									lstX.add(mapIntegerKeyedX.get(intKey));
									lstY.add(mapIntegerKeyedY.get(intKey));
								}
							}
							if (1 < lstX.size()) {
								douArrayX = ArrayUtils.toPrimitive(lstX.toArray(new Double[lstX.size()]));
								douArrayY = ArrayUtils.toPrimitive(lstY.toArray(new Double[lstY.size()]));
								objArrayRowData[11] = this.getPearsonProductMomentCorrelationCoefficient(douArrayX, 
                                                                                                         douArrayY);   	
							}
							else {
								objArrayRowData[11] = "";
							}
						}
						else {
							objArrayRowData[11] = "";
						}
					}
					else {
						objArrayRowData[ 9] = "";
						objArrayRowData[10] = "";
						objArrayRowData[11] = "";
					}
					
					//////////////////////////////////////////
					// Writing the row data in the worksheet    
					//////////////////////////////////////////
					this.objReportWriter.writeRowData(objArrayRowData);
				}
			}
			this.objReportWriter.closeSheet();
		}
		this.saveAllProcessedSheetsData();
	}

	private boolean checkModelNameAsPrimary(String strInModelName) {
		/////////////////////////////////////////////////////////////////
		// It gives a better performance without making any extra work   
		// to build a list from the array                                
		///////////////////////////////////////////////////////////////// 
		if (Arrays.asList(this.strArrayPrimaryModelNames).contains(strInModelName)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	private boolean getBoundedC(String strInC) {
		if (strInC == null) { 
			return false; }
		
		return (!(strInC.equals("P")));
	}
	
	private String translateBooleanValue(boolean bolInValue) {
		if (bolInValue == true) {
			return "Yes";
		}
		else {
			return "No";
		}
	}
	
	private double getPearsonProductMomentCorrelationCoefficient(double[] douInArrayX,
			                                                     double[] douInArrayY) {
		double douPearsonProductMomentCorrelationCoefficient;
		
		douPearsonProductMomentCorrelationCoefficient = 0;
		try {
			douPearsonProductMomentCorrelationCoefficient = new PearsonsCorrelation().correlation(douInArrayX, 
                                                                                                  douInArrayY);
		}
		catch (IllegalArgumentException e) {
			this.objReportWriter.closeSheet();
			this.saveAllProcessedSheetsData();
			System.err.println("Exception in trying to make the Pearson's correlation coefficient");
			e.printStackTrace();
			objLogger.error("Validator.getPearsonProductMomentCorrelationCoefficient", 
			                e);
			throw new RuntimeException();
		}
		
		return douPearsonProductMomentCorrelationCoefficient;
	}
	
	private void saveAllProcessedSheetsData() {
		//////////////////////////////////////////////
		// Writing all the the data in the .xls file    
		//////////////////////////////////////////////
		this.objReportWriter.close(System.getProperty("user.dir") + 
						           System.getProperty("file.separator") + 
	                               "report_" +
	                               this.objDataFormat.format(new Date()) + 
	                               ".xls");
	}
}
