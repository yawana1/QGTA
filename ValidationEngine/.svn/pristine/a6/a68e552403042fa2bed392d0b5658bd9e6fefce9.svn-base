package io;

import java.io.IOException;
import java.lang.Exception;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;

import data.Report;
import io.EntrySummaryReader;
import io.ExlSummaryReader;
import io.ExperimentSummaryReader;
import io.LocSummaryReader;

public class ReportDirectorySimpleFileVisitor extends SimpleFileVisitor<Path> {
	static Logger objLogger = Logger.getLogger(ReportDirectorySimpleFileVisitor.class.getName());
	private List<Report> lstCurrentReports;
	private List<Report> lstPreviousReports;
	private Set<String> setSummaryFileNames;
	private EntrySummaryReader objEntrySummaryReader;
	private ExlSummaryReader objExlSummaryReader;
	private LocSummaryReader objLocSummaryReader;
	private ExperimentSummaryReader objExperimentSummaryReader;
	
	public ReportDirectorySimpleFileVisitor() throws Exception {
		this.lstCurrentReports = new ArrayList<Report>();
		this.lstPreviousReports = new ArrayList<Report>();
		this.setSummaryFileNames = new HashSet<String>();
		this.setSummaryFileNames.add("entrySummary.txt");
		this.setSummaryFileNames.add("exlSummary.txt");
		this.setSummaryFileNames.add("experimentSummary.txt");
		this.setSummaryFileNames.add("locSummary.txt");		
	}

	@Override public FileVisitResult visitFile(Path objInFilePath,
                                               BasicFileAttributes objInBasicFileAttributes) throws IOException {
		String[] strArrayLineParts;
		String strFileName;
		
		strArrayLineParts = objInFilePath.toString().split("\\/");
		strFileName = strArrayLineParts[strArrayLineParts.length - 1];
		if (this.setSummaryFileNames.contains(strFileName)) {
			this.checkReport(objInFilePath);
		} 
		
		return FileVisitResult.CONTINUE;
	}
	
	private void checkReport(Path objInFilePath) {
		String[] strArrayLineParts;
		String strTrialName;
		Report objCurrentReport;
		int intReportIndex;
		String strTimeStamp;
		Report objPreviousReport;
		
		System.out.println("Checking the file: " + objInFilePath.toString() + "...");
		strArrayLineParts = objInFilePath.toString().split("\\/");
		///////////////////////
		// Current run report  
		///////////////////////
		if (!(strArrayLineParts[strArrayLineParts.length - 2].startsWith("ARCHIVE_"))) {
			strTrialName = strArrayLineParts[strArrayLineParts.length - 2];
			objCurrentReport = new Report(strTrialName);
			/////////////////////////////////////////////
			// It is not in the list of current reports    
			/////////////////////////////////////////////
			if (!(this.lstCurrentReports.contains(objCurrentReport))) {
				this.lstCurrentReports.add(objCurrentReport);
			}
			//////////////////////////////////////////////////////////
			// The current report is filled with (more) summary data  
			//////////////////////////////////////////////////////////
			this.fillSummaryData(this.lstCurrentReports,
                                 this.lstCurrentReports.indexOf(objCurrentReport),
                                 objInFilePath);
		}
		//////////////////////////////////////////////////////////////////////////////
		// Previous run report
		// It must be time stamped since there can be more than one previous report;  
		// only the most recent previous report is chosen                          
		//////////////////////////////////////////////////////////////////////////////
		else {
			strTrialName = strArrayLineParts[strArrayLineParts.length - 3];
			objPreviousReport = new Report(strTrialName);
			//////////////////////////////////////////////
			// It is not in the list of previous reports    
			//////////////////////////////////////////////
			if (!(this.lstPreviousReports.contains(objPreviousReport))) {
				objPreviousReport.setTimeStamp(this.getTimeStamp(objInFilePath,
						                                         strArrayLineParts[strArrayLineParts.length - 2]));
				this.lstPreviousReports.add(objPreviousReport);
				this.fillSummaryData(this.lstPreviousReports,
                                     this.lstPreviousReports.indexOf(objPreviousReport),
                                     objInFilePath);
			}
			//////////////////////////////////////////
			// It is in the list of previous reports      
			//////////////////////////////////////////
			else {
				intReportIndex = this.lstPreviousReports.indexOf(objPreviousReport);
				strTimeStamp = this.getTimeStamp(objInFilePath,
                                                 strArrayLineParts[strArrayLineParts.length - 2]);
				////////////////////////////////////////////////////////////////////////////////
				// The new summary data is coherent with the time stamp of the previous report  
				////////////////////////////////////////////////////////////////////////////////
				if (this.lstPreviousReports.get(intReportIndex).getTimeStamp().equals(strTimeStamp)) {
					System.out.println("The report is updated with data from " + objInFilePath.toString());
					this.fillSummaryData(this.lstPreviousReports,
							             intReportIndex,
                                         objInFilePath);
				}
				//////////////////////////////////////////////////////////////////////////////
				// The previous report is newer than the one in the list of previous reports    
				//////////////////////////////////////////////////////////////////////////////
				else {
					if (this.lstPreviousReports.get(intReportIndex).isOlderThan(strTimeStamp)) {
						System.out.println(objInFilePath.toString() + " is accepted for being newer");
						this.lstPreviousReports.remove(intReportIndex);
						objPreviousReport = new Report(strTrialName);
						objPreviousReport.setTimeStamp(this.getTimeStamp(objInFilePath,
                                                                         strArrayLineParts[strArrayLineParts.length - 2]));
						this.lstPreviousReports.add(objPreviousReport);
						this.fillSummaryData(this.lstPreviousReports,
                                             this.lstPreviousReports.indexOf(objPreviousReport),
                                             objInFilePath);
					}
					else {
						System.out.println(objInFilePath.toString() + " is rejected for being older");
					}
				}
			}
		}
	}
	
	private String getTimeStamp(Path objInFilePath,
			                    String strInArchiveDirectoryName) {
		Report objVoidReport;
		String strTimeStamp;
		String[] strArrayLineParts;
		
		objVoidReport = new Report("");
		strTimeStamp = "";
		try {
			strArrayLineParts = strInArchiveDirectoryName.split("_");
			if (strArrayLineParts.length == 2) {
				strTimeStamp = strArrayLineParts[1];
				try {
					if (!(objVoidReport.checkTimeStampFormat(strTimeStamp))) {
						throw new Exception("The format of the timestamp given is incorrect when treating with " + 
								            objInFilePath.toString());
					}
				}
				catch (Exception e) {
					e.printStackTrace();
					objLogger.error("ReportDirectorySimpleFileVisitor.getTimeStamp", 
					                e);
					throw new RuntimeException();
				}
			}
			else {
				throw new Exception("There are more than two parts from splitting " + objInFilePath.toString());
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			objLogger.error("ReportDirectorySimpleFileVisitor.getTimeStamp", 
			                e);
			throw new RuntimeException();
		}
		
		return strTimeStamp;
	}
		
	private void fillSummaryData(List<Report> lstInReports,
			                     int intInReportIndex,
			                     Path objInFilePath) {
		String[] strArrayLineParts;
		String strFileName;
		
		System.out.println("Getting the summary data from the file: " + objInFilePath + "...");		
		strArrayLineParts = objInFilePath.toString().split("\\/");
		strFileName = strArrayLineParts[strArrayLineParts.length - 1];
		switch (strFileName) {
			/////////////////////
			// entrySummary.txt    
			/////////////////////				
			case "entrySummary.txt":
				try {
					if ((lstInReports.get(intInReportIndex).getRecordsNumbers().isEmpty()) && 
						(lstInReports.get(intInReportIndex).getEntryEstimates().isEmpty())) {
						this.objEntrySummaryReader = new EntrySummaryReader(objInFilePath);
						System.out.println("Setting the records numbers...");
						lstInReports.get(intInReportIndex).setRecordsNumbers(this.objEntrySummaryReader.getRecordsNumbers());
						System.out.println("Setting the entry estimates...");
						lstInReports.get(intInReportIndex).setEntryEstimates(this.objEntrySummaryReader.getEstimates());
						System.out.println("Setting the raw counts...");
						lstInReports.get(intInReportIndex).setRawCounts(this.objEntrySummaryReader.getRawCounts());
					}
					else {
						throw new Exception("A possible repetition of entrySummary detected in " + objInFilePath.toString()); 
					}
				}
				catch (Exception e) {
					e.printStackTrace();
					objLogger.error("ReportDirectorySimpleFileVisitor.FileVisitResult", 
			                        e);	
					throw new RuntimeException();
				}
				break;

			///////////////////
			// exlSummary.txt    
			///////////////////				
			case "exlSummary.txt":
				try {
					if (lstInReports.get(intInReportIndex).getExlRawMeans().isEmpty())  {
						this.objExlSummaryReader = new ExlSummaryReader(objInFilePath);
						System.out.println("Setting the exl raw means...");
						lstInReports.get(intInReportIndex).setExlRawMeans(this.objExlSummaryReader.getRawMeans());
					}
					else {
						throw new Exception("A possible repetition of exlSummary detected in " + objInFilePath.toString()); 
					}
				}
				catch (Exception e) {
					e.printStackTrace();
					objLogger.error("ReportDirectorySimpleFileVisitor.FileVisitResult", 
			                        e);
					throw new RuntimeException();
				}
				break;

			//////////////////////////
			// experimentSummary.txt      
			//////////////////////////				
			case "experimentSummary.txt":
				try {
					if (lstInReports.get(intInReportIndex).getLocationsNumbers().isEmpty())  {
						this.objExperimentSummaryReader = new ExperimentSummaryReader(objInFilePath);
						System.out.println("Setting the locations numbers...");
						lstInReports.get(intInReportIndex).setLocationsNumbers(this.objExperimentSummaryReader.getLocationsNumbers()); 
					}
					else {
						throw new Exception("A possible repetition of experimentSummary detected in " + objInFilePath.toString()); 
					}
				}
				catch (Exception e) {
					e.printStackTrace();
					objLogger.error("ReportDirectorySimpleFileVisitor.FileVisitResult", 
	                        		e);
					throw new RuntimeException();
				}				
				break;

			///////////////////
			// locSummary.txt  
			///////////////////				
			case "locSummary.txt":
				try {
					if (lstInReports.get(intInReportIndex).getLocationEstimates().isEmpty())  {
						this.objLocSummaryReader = new LocSummaryReader(objInFilePath);
						System.out.println("Setting the location estimates...");
						lstInReports.get(intInReportIndex).setLocationEstimates(this.objLocSummaryReader.getEstimates());
					}
					else {
						throw new Exception("A possible repetition of locSummary detected in " + objInFilePath.toString()); 
					}
				}	
				catch (Exception e) {
					e.printStackTrace();
					objLogger.error("ReportDirectorySimpleFileVisitor.FileVisitResult", 
	                       		    e);	
					throw new RuntimeException();
				}				
				break;
		}
	}
	
	public List<Report> getCurrentReports() {
		return this.lstCurrentReports;
	}

	public List<Report> getPreviousReports() {
		return this.lstPreviousReports;
	}
}
