package data;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.io.FileUtils;

import report.OutputDeleteWorkingDir;
import report.OutputExcel;
import report.OutputOutlier;
import report.OutputVat;
import transformation.BrazilYieldTransformation;
import transformation.Grm;
import transformation.PRMCorrection;
import transformation.SoybeanYieldTransformation;
import transformation.SpatialCorrection;
import validate.NullColumns;
import asreml.AsremlGlobals.GrmType;
import asreml.input.AsremlModelBlup;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;

import db.modules.InbredEval;
import db.modules.SQLBuilder;

/**
 * Serialize and Deserialize xml data into objects using XStream
 * 
 * @author Scott Smith
 *
 * @see <a href="http://xstream.codehaus.org/index.html">http://xstream.codehaus.org/index.html</a>
 */
public class XML {
	public final static XML INSTANCE = new XML();
	private XStream xstream;

	/**
	 * Also can use a StaxDriver instead of Dom
	 */
	private XML(){
		xstream = new XStream(new DomDriver());
		
		xstream.alias(SoybeanYieldTransformation.class.getSimpleName(), SoybeanYieldTransformation.class);
		xstream.alias(BrazilYieldTransformation.class.getSimpleName(), BrazilYieldTransformation.class);
		xstream.alias(SpatialCorrection.class.getSimpleName(), SpatialCorrection.class);
		xstream.alias(PRMCorrection.class.getSimpleName(),PRMCorrection.class);
		xstream.alias(Grm.class.getSimpleName(), Grm.class);
		xstream.alias(OutputExcel.class.getSimpleName(), OutputExcel.class);
		xstream.alias(OutputVat.class.getSimpleName(), OutputVat.class);
		xstream.alias(OutputOutlier.class.getSimpleName(), OutputOutlier.class);
		xstream.alias(OutputDeleteWorkingDir.class.getSimpleName(), OutputDeleteWorkingDir.class);
		xstream.alias(InbredEval.class.getSimpleName(), InbredEval.class);
		xstream.alias(SQLBuilder.class.getSimpleName(), SQLBuilder.class);
		xstream.alias(AsremlModelBlup.class.getSimpleName(), AsremlModelBlup.class);
		xstream.alias(GrmType.class.getSimpleName(), GrmType.class);
		xstream.alias(NullColumns.class.getSimpleName(), NullColumns.class);
	}

	/***
	 * Not Aliased
	 * @param <T>
	 * @param file
	 * @return
	 */
	public <T> T deserialize(String file){
		@SuppressWarnings("unchecked")
		T result = (T) xstream.fromXML(new File(file));
		return result;
	}

	/***
	 * Alias all objects in the graph of Object root to there class.getSimpleName
	 * ex. xstream.alisas("Trait", Trait.class);
	 * @param file
	 * @param root
	 */
	public void deserialize(String file, Object root){
		objectTree(root.getClass(), new ArrayList<String>());
		xstream.fromXML(new File(file), root);
	}

	/***
	 * Alias all objects in the graph of Object root to there class.getSimpleName
	 * ex. xstream.alisas("Trait", Trait.class);
	 * @param file
	 * @param root
	 * @throws IOException 
	 */
	public void deserialize(String file, Object root, Map<String,String> replace) throws IOException{
		objectTree(root.getClass(), new ArrayList<String>());
		String text = FileUtils.readFileToString(new File(file));
		
		for(Entry<String, String> replacement : replace.entrySet()){
			text = text.replace("$"+replacement.getKey(), replacement.getValue());
		}
		
		xstream.fromXML(text, root);
	}
	
	public String serialize(Object o){
		xstream.alias(o.getClass().getSimpleName(), o.getClass());
		return xstream.toXML(o);
	}
	
	public void serialize(Object o, String file) throws IOException{
		Writer writer = new FileWriter(new File(file));
		xstream.alias(o.getClass().getSimpleName(), o.getClass());
		
		xstream.toXML(o, writer);
	}

	/***
	 * Traverse object graph perform action on each node
	 * @param c
	 * @param visited
	 */
	//TODO pull out into own class.
	public void objectTree(Class<?> c,List<String> visited){
		if(!visited.contains(c.getName())){
			visited.add(c.getName());
			xstream.alias(c.getSimpleName(), c);//actual performed action
			for(Field field : c.getDeclaredFields()){
				Type type = field.getGenericType();
				if(type instanceof ParameterizedType){
					ptRecurse((ParameterizedType) type, visited);
				}
				else{
					recurse(field, visited);
				}
			}
		}
	}

	private void recurse(Field field, List<String> visited){
		field.setAccessible(true);  //access private memebers
		if(field.getGenericType() instanceof Class<?>){
			Class<?> c = (Class<?>)field.getGenericType();
			if(!isPrimitive(c)){
				objectTree(c, visited);
			}
		}
	}
	
	/***
	 * Traverse List a Objects that are use as Generics
	 * Can be nested.
	 * @param pType
	 * @param visited
	 */
	private void ptRecurse(ParameterizedType pType, List<String> visited){
		for(Type genericType:pType.getActualTypeArguments()){
			if(genericType instanceof Class){
				objectTree((Class<?>)genericType, visited);
			}
			else if(genericType instanceof ParameterizedType){
				ptRecurse((ParameterizedType) genericType, visited);
			}
		}
	}
	
	public static boolean isPrimitive(Class<?> clazz){
		return clazz.isPrimitive() ||
		clazz.equals(Boolean.class) ||
		clazz.equals(Byte.class) ||
		clazz.equals(Short.class) ||
		clazz.equals(Integer.class) ||
		clazz.equals(Long.class) ||
		clazz.equals(Float.class) ||
		clazz.equals(Double.class) ||
		clazz.equals(String.class) ||
		clazz.equals(Character.class);
	}
}