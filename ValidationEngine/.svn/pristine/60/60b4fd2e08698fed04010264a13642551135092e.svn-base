package validation;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
//import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math.stat.correlation.PearsonsCorrelation;
import org.apache.log4j.Logger;

import asreml.output.AsrVariance;
import data.xml.objects.App;

import data.Model;
import data.Report;
import data.Trait;
import data.Trial;
import io.ReportDirectorySimpleFileVisitor;
import io.ReportWriter;
import io.WorkDirectorySimpleFileVisitor;
import io.XMLFileParser;

public class Validator {
	
	static Logger objLogger = Logger.getLogger(Validator.class.getName());
	private Path objPreviousReportsDirectoryPath;
	private List<Trial> lstTrials;
	private List<Report> lstCurrentReports;
	private List<Report> lstPreviousReports;
	private Map<String, Integer> objMapCurrentReportIndexes;
	private Map<String, Integer> objMapPreviousReportIndexes;	
	private TreeMap<String, List<Trial>> objTreeMapTrialsByTrait;
	private ReportWriter objReportWriter;
	private DateFormat objDataFormat;
	
	public Validator(Path objInPreviousReportsDirectoryPath) {		
		this.objPreviousReportsDirectoryPath = objInPreviousReportsDirectoryPath;
	}
	
	public void run() {
		try {
			this.coverWorkDirectory();
			this.coverReportDirectory();
			this.connectReportWithTrial();
			this.getTrialsByTrait();
			this.processTraits();
		}
		catch (IOException e) {
			objLogger.error("Validator.run", 
                            e);
		}
	}

	private void coverWorkDirectory() throws IOException {
		WorkDirectorySimpleFileVisitor objWorkDirectorySimpleFileVisitor;
		
		objLogger.info("Processing the work directory...");
		objWorkDirectorySimpleFileVisitor = null;
		try {
			objWorkDirectorySimpleFileVisitor = new WorkDirectorySimpleFileVisitor();
		}
		catch (Exception e) {
			objLogger.error("Validator.coverWorkDirectory", 
                            e);
		}
		Files.walkFileTree(Paths.get(App.INSTANCE.getWorkDirectory()), 
				           objWorkDirectorySimpleFileVisitor);
		this.lstTrials = objWorkDirectorySimpleFileVisitor.getTrials();
		this.getAsrData();
	}

	private void getAsrData() {
		int intTrialIndex;
		int intModelIndex;
		int intTraitIndex;
		Path objAsrFilePath;
		asreml.Trait objAsremlTrait;
		List<asreml.Trait> lstArsemlTraits;
		asreml.output.AsrData objAsrData;
		Map<String, AsrVariance> objMapAsrVariances;
		boolean bolBoundedVCs;
		
		objLogger.info("Processing the capture of the Asr data...");
		for (Trial objTrial : this.lstTrials) {
			intTrialIndex = this.lstTrials.indexOf(objTrial);
			for (Model objModel : objTrial.getModels()) {
				intModelIndex = this.lstTrials.get(intTrialIndex).getModels().indexOf(objModel);
				for (Trait objTrait : objModel.getTraits()) {
					intTraitIndex = this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits().indexOf(objTrait);
					///////////////////////////////////////////////////////////////////////////////////////////////
					// The AsrData class in the Trial Analysis project adds the extension ".asr" to any filename,   
					// even having the same extension!
					///////////////////////////////////////////////////////////////////////////////////////////////					
					objAsrFilePath = FileSystems.getDefault().getPath(objTrait.getPath().toString(), "asreml");
					objAsremlTrait = new asreml.Trait(objTrait.getName(), 
							                          0);
					lstArsemlTraits = new ArrayList<asreml.Trait>();
                    lstArsemlTraits.add(objAsremlTrait);
                    objLogger.info("Reading the Asr data in " + objAsrFilePath.toString() + ".asr...");
                    objAsrData = new asreml.output.AsrData(objAsrFilePath,
					                                       0,
					                                       0,
					                                       0,
					                                       lstArsemlTraits,
											               0.0);
					this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits().get(intTraitIndex).setConverged(objAsrData.isConverged());
					objMapAsrVariances = objAsrData.getVariance(objAsremlTrait);
					if (objMapAsrVariances.get("Variance") != null) {
						bolBoundedVCs = this.getBoundedC(objMapAsrVariances.get("Variance").getC());
					}
					else {
						bolBoundedVCs = false;
					}
					this.lstTrials.get(intTrialIndex).getModels().get(intModelIndex).getTraits().get(intTraitIndex).setBoundedVCs(bolBoundedVCs);
				}
			}
		}
	}
	
	private void coverReportDirectory() throws IOException,
    										   FileNotFoundException {
		boolean bolARCHIVEFlag;
		ReportDirectorySimpleFileVisitor objReportDirectorySimpleFileVisitor1;
		ReportDirectorySimpleFileVisitor objReportDirectorySimpleFileVisitor2;

		objLogger.info("Processing the report directory(ies)...");
		objReportDirectorySimpleFileVisitor1 = null;
		objReportDirectorySimpleFileVisitor2 = null;
		// ////////////////////////////////////////////////////////////
		// If the ARCHIVE subdirectories are preferred to be targeted  
		///////////////////////////////////////////////////////////////
		if (this.objPreviousReportsDirectoryPath == null) {
			bolARCHIVEFlag = true;
			try {
				objReportDirectorySimpleFileVisitor1 = new ReportDirectorySimpleFileVisitor(bolARCHIVEFlag);
			}
			catch (Exception e) {
				objLogger.error("Validator.coverReportDirectory", 
								e);
			}
			Files.walkFileTree(Paths.get(App.INSTANCE.getReportDirectory()), 
				           	   objReportDirectorySimpleFileVisitor1);
			this.lstCurrentReports = objReportDirectorySimpleFileVisitor1.getCurrentReports();
			this.lstPreviousReports = objReportDirectorySimpleFileVisitor1.getPreviousReports();
		}
		////////////////////////////////////////////////////////////
		// If a previous reports directory is given to be targeted  
        ////////////////////////////////////////////////////////////
		else {
			bolARCHIVEFlag = false;
			try {
				objReportDirectorySimpleFileVisitor1 = new ReportDirectorySimpleFileVisitor(bolARCHIVEFlag);
				objReportDirectorySimpleFileVisitor2 = new ReportDirectorySimpleFileVisitor(bolARCHIVEFlag);
			}
			catch (Exception e) {
				objLogger.error("Validator.coverReportDirectory", 
								e);
			}
			Files.walkFileTree(Paths.get(App.INSTANCE.getReportDirectory()), 
		           	   		   objReportDirectorySimpleFileVisitor1);
			this.lstCurrentReports = objReportDirectorySimpleFileVisitor1.getCurrentReports();
			Files.walkFileTree(this.objPreviousReportsDirectoryPath,
	                           objReportDirectorySimpleFileVisitor2);
			this.lstPreviousReports = objReportDirectorySimpleFileVisitor2.getCurrentReports();		
		}
	}
	
	private void connectReportWithTrial() {
		int intListIndex;
		
		objLogger.info("Connecting reports with trials...");
		////////////////////////////////////////////////////////////////////////////////////////
		// "Connects" two objects from different classes, "Report" and "Trial", by trial name.  
		////////////////////////////////////////////////////////////////////////////////////////
		this.objMapCurrentReportIndexes = new HashMap<String, Integer>();
		for (intListIndex = 0;
			 intListIndex < this.lstCurrentReports.size();
			 intListIndex = intListIndex + 1) {
			if (!(this.objMapCurrentReportIndexes.containsKey(this.lstCurrentReports.get(intListIndex).getTrialName()))) {
				this.objMapCurrentReportIndexes.put(this.lstCurrentReports.get(intListIndex).getTrialName(), 
						                            intListIndex);
			}
			else {
				objLogger.error("The current report " +  this.lstCurrentReports.get(intListIndex).getTrialName() + 
				                " is repeated");
		        throw new RuntimeException("The current report " +  this.lstCurrentReports.get(intListIndex).getTrialName() + 
		                                   " is repeated");
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////////
		// If there is a previous report with the same trial name and relative path with the current report,  
		// then it is accepted to save HashMaps.                                                                               
		//////////////////////////////////////////////////////////////////////////////////////////////////////
		this.objMapPreviousReportIndexes = new HashMap<String, Integer>();		
		for (intListIndex = 0;
			 intListIndex < this.lstPreviousReports.size();
			 intListIndex = intListIndex + 1) {
			if ((this.lstCurrentReports.indexOf(this.lstPreviousReports.get(intListIndex))) != -1) {
				if (!(this.objMapPreviousReportIndexes.containsKey(this.lstPreviousReports.get(intListIndex).getTrialName()))) {
					this.objMapPreviousReportIndexes.put(this.lstPreviousReports.get(intListIndex).getTrialName(), 
							                         	 intListIndex);
				}
				else {
					objLogger.error("The previous report " + this.lstPreviousReports.get(intListIndex).getTrialName() + 
				                	" is repeated");
					throw new RuntimeException("The previous report " + this.lstPreviousReports.get(intListIndex).getTrialName() + 
			                               	   " is repeated");
				}
			}
		}
	}
	
	private void getTrialsByTrait() {
		List<Trial> lstTrials;
		
		objLogger.info("Processing the inverse relationship of trials by trait...");
		this.objTreeMapTrialsByTrait = new TreeMap<String, List<Trial>>();
		for (Trial objTrial : this.lstTrials) {
			for (Model objModel : objTrial.getModels()) {
				for (Trait objTrait : objModel.getTraits()) { 
					if (!(this.objTreeMapTrialsByTrait.containsKey(objTrait.getName()))) {
						lstTrials = new ArrayList<Trial>();
						lstTrials.add(objTrial);
						this.objTreeMapTrialsByTrait.put(objTrait.getName(), 
								                     lstTrials);
					}
					else {
						if (!(this.objTreeMapTrialsByTrait.get(objTrait.getName()).contains(objTrial))) {
							this.objTreeMapTrialsByTrait.get(objTrait.getName()).add(objTrial);
						}
					}
				}
			}
		}
		try {
			if (this.objTreeMapTrialsByTrait.isEmpty()) {
				objLogger.error("No useful trial data for the traits");
				throw new Exception("No useful trial data for the traits");
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			objLogger.error("Validator.getTrialsByTrait", 
							e);
			throw new RuntimeException();
		}
	}
	
	private void processTraits() {
		String[] strArrayHeaders;
		Iterator<Map.Entry<String, List<Trial>>> iteTrialsByTrait;
		Map.Entry<String, List<Trial>> objMapEntry;
		String strTraitName;
		int intPreviousReportIndex;
		int intCurrentReportIndex;
		Object[] objArrayRowData;
		String strCropName;
		String strTypeName;
		String strStageName;
		String strCountryName;
		String strSeasonName;
		String strFirstModelName;
		String strSecondModelName;
		Path objPathXMLDirectory;
		DirectoryStream<Path> objDirectoryStream;
		int intXMLFilesNumber;
		Path objPathXMLFile;
		XMLFileParser objXMLFileParser;
		int intPreviousLocationsNumber;
		int intCurrentLocationsNumber;
		int intPreviousGenotypesNumber;
		int intCurrentGenotypessNumber;		
		int intTrialIndex;
		int intFirstModelIndex;
		int intSecondModelIndex;
		double douEntryCorrelationEstimate;
		double douEntryCorrelationCoreCheck;	
		double douEntryCorrelationRank;	
		double douExlCorrelationRawMean;
		double douExlCorrelationCoreCheck;	
		double douExlCorrelationCav;	
		double douLocCorrelationEstimate;	
		double douLocCorrelationCv;	
		double douLocCorrelationCheckCv;	
		double douLocCorrelationRawCoreCheckMean;	

		objLogger.info("Processing the traits ...");
		strArrayHeaders = new String[28];
		strArrayHeaders[ 0] = "Crop";
		strArrayHeaders[ 1] = "Type";
		strArrayHeaders[ 2] = "Stage";
		strArrayHeaders[ 3] = "Country";
		strArrayHeaders[ 4] = "Yield";
		strArrayHeaders[ 5] = "Season";
		strArrayHeaders[ 6] = "Trial";
		strArrayHeaders[ 7] = "Locations";
		strArrayHeaders[ 8] = "Locations Deviation";
		strArrayHeaders[ 9]	= "Genotypes"; 	
		strArrayHeaders[10] = "Genotypes Deviation";
		strArrayHeaders[11] = "Total rawCounts";
		strArrayHeaders[12] = "First Model";		
		strArrayHeaders[13] = "FM Converged";
		strArrayHeaders[14] = "Bounded VCs";
		strArrayHeaders[15] = "Second Model";		
		strArrayHeaders[16] = "SM Converged";
		strArrayHeaders[17] = "Correlation Of estimate (entrySummary)";
		strArrayHeaders[18] = "Correlation Of coreCheck (entrySummary)";	
		strArrayHeaders[19] = "Correlation Of rank (entrySummary)";	
		strArrayHeaders[20] = "Correlation Of rawMean (exlSummary)";
		strArrayHeaders[21] = "Correlation Of coreCheck (exlSummary)";	
		strArrayHeaders[22] = "Correlation Of CAV (exlSummary)";	
		strArrayHeaders[23] = "Correlation Of estimate (locSummary)";	
		strArrayHeaders[24] = "Correlation Of cv (locSummary)";	
		strArrayHeaders[25] = "Correlation Of checkCV (locSummary)";	
		strArrayHeaders[26] = "Correlation Of rawCoreCheckMean (locSummary)";	
		strArrayHeaders[27] = "Creation Time";
		
		this.objReportWriter = new ReportWriter();
		this.objDataFormat = new SimpleDateFormat("MM_dd_yyyy_HH_mm_ss");
		iteTrialsByTrait = this.objTreeMapTrialsByTrait.entrySet().iterator();
		while (iteTrialsByTrait.hasNext())
		{
			objMapEntry = (Map.Entry<String, List<Trial>>)iteTrialsByTrait.next();
			strTraitName = objMapEntry.getKey();
			objLogger.info("Generating trial data for the trait: " + strTraitName);
			this.objReportWriter.createSheet(strTraitName,
					                         strArrayHeaders);
			for (Trial objTrial : objMapEntry.getValue()) {
				objArrayRowData = new Object[strArrayHeaders.length];
				objPathXMLDirectory = objTrial.getPath();
				objPathXMLFile = null;
				objDirectoryStream = null;
				try {
					objDirectoryStream = Files.newDirectoryStream(objPathXMLDirectory);
					intXMLFilesNumber = 0;
					for (Path objPath: objDirectoryStream) {
						if (objPath.getFileName().toString().toLowerCase().endsWith(".xml")) {
							objPathXMLFile = objPath; 
							intXMLFilesNumber = intXMLFilesNumber + 1;
						}
					}
				}
				catch (Exception e) {
					e.printStackTrace();
					objLogger.error("Validator.processTraits", 
									e);
					throw new RuntimeException();
				}
				finally {
					if (objDirectoryStream != null)
					{
						try {
							objDirectoryStream.close();
						}
						catch (Exception e) {
					        e.printStackTrace();
					        objLogger.error("Validator.processTraits", 
							                e);
					        throw new RuntimeException();
						}
					}
				}
				if (intXMLFilesNumber == 1) {
					objXMLFileParser = new XMLFileParser(objPathXMLFile);
					strCropName = objXMLFileParser.getCropName();
					strTypeName = objXMLFileParser.getTypeName();
					strStageName = objXMLFileParser.getStageName();
					strCountryName = "";
					strSeasonName = objXMLFileParser.getSeasonName();
					strFirstModelName = objXMLFileParser.getFirstModelName();
					strSecondModelName = objXMLFileParser.getSecondModelName();
				}
				else {
					strCropName = "";
					strTypeName = "";
					strStageName = "";
					strCountryName = "";
					strSeasonName = "";
					strFirstModelName = "";
					strSecondModelName = "";
				}
				
				//System.out.println("objPathXMLFile: " + objPathXMLFile.toString());
				//System.out.println("strCropName: " + strCropName);
				//System.out.println("strTypeName: " + strTypeName);
				//System.out.println("strStageName: " + strStageName);
				//System.out.println("strCountryName: " + strCountryName);
				//System.out.println("strSeasonName: " + strSeasonName);
				//System.out.println("strFirstModelName: " + strFirstModelName);
				//System.out.println("strSecondModelName: " + strSecondModelName);
				//System.exit(0);
				
				////////////////////////////
				// The column "Crop"  
				////////////////////////////
				objArrayRowData[ 0] = strCropName;
				
				////////////////////////////
				// The column "Type"  
				////////////////////////////
				objArrayRowData[ 1] = strTypeName;
				
				////////////////////////////
				// The column "Stage"  
				////////////////////////////
				objArrayRowData[ 2] = strStageName;
				
				////////////////////////////
				// The column "Country"  
				////////////////////////////
				objArrayRowData[ 3] = "";

				////////////////////////////
				// The column "Yield"  
				////////////////////////////
				objArrayRowData[ 4] = "";
				
				/////////////////////////////
				// The column "Season"  
				/////////////////////////////
				objArrayRowData[ 5] = strSeasonName;
				
				////////////////////////////
				// The column "Trial"  
				////////////////////////////
				objArrayRowData[ 6] = objTrial.getTrialName();
				
				if (this.objMapCurrentReportIndexes.containsKey(objTrial.getTrialName())) {
					intCurrentReportIndex = this.objMapCurrentReportIndexes.get(objTrial.getTrialName());
				}
				else {
					intCurrentReportIndex = -1;
				}
				if (this.objMapPreviousReportIndexes.containsKey(objTrial.getTrialName())) {
					intPreviousReportIndex = this.objMapPreviousReportIndexes.get(objTrial.getTrialName());
				}
				else {
					intPreviousReportIndex = -1;
				}
				if (intCurrentReportIndex != -1) {
					if (this.lstCurrentReports.get(intCurrentReportIndex).getExperimentLocationsNumbers().containsKey(strTraitName)) {
						intCurrentLocationsNumber = this.lstCurrentReports.get(intCurrentReportIndex).getExperimentLocationsNumbers().get(strTraitName);
						intCurrentGenotypessNumber = this.lstCurrentReports.get(intCurrentReportIndex).getEntryGenotypesNumbers().get(strTraitName);
						////////////////////////////////////////////
						// The columns "Locations" and "Genotypes"  
						////////////////////////////////////////////
						objArrayRowData[ 7] = intCurrentLocationsNumber;
						objArrayRowData[ 9] = intCurrentGenotypessNumber;
						if (intPreviousReportIndex != -1) {
							if (this.lstPreviousReports.get(intPreviousReportIndex).getExperimentLocationsNumbers().containsKey(strTraitName)) {
								intPreviousLocationsNumber = this.lstPreviousReports.get(intPreviousReportIndex).getExperimentLocationsNumbers().get(strTraitName);
								intPreviousGenotypesNumber = this.lstPreviousReports.get(intPreviousReportIndex).getEntryGenotypesNumbers().get(strTraitName);
								////////////////////////////////////////////////////////////////  
								// The columns "Locations Deviation" and "Genotypes Deviation"  
								////////////////////////////////////////////////////////////////
								objArrayRowData[ 8] = intCurrentLocationsNumber - intPreviousLocationsNumber;
								objArrayRowData[10] = intCurrentGenotypessNumber - intPreviousGenotypesNumber;
							}
						}
					}
					if (this.lstCurrentReports.get(intCurrentReportIndex).getEntryRawCounts().containsKey(strTraitName)) {
						/////////////////////////////////
						// The column "Total rawCounts"  
						/////////////////////////////////
						objArrayRowData[11] = this.lstCurrentReports.get(intCurrentReportIndex).getEntryRawCounts().get(strTraitName);
					}
				}
			
				intTrialIndex = this.lstTrials.indexOf(objTrial);

				///////////////////////////////////////
				// The First And Second Model Indexes  
				///////////////////////////////////////
				intFirstModelIndex = -1;
				intSecondModelIndex = -1;				
				for (Model objModel : this.lstTrials.get(intTrialIndex).getModels()) {
					if ((!(strFirstModelName.equals(""))) &&
						(objModel.getName().equals(strFirstModelName))) {
						intFirstModelIndex = this.lstTrials.get(intTrialIndex).getModels().indexOf(objModel);
					}
					if ((!(strSecondModelName.equals(""))) &&
						(objModel.getName().equals(strSecondModelName))) {
						intSecondModelIndex = this.lstTrials.get(intTrialIndex).getModels().indexOf(objModel);
					}
				}

				////////////////////
				// The First Model   
				////////////////////
				if (intFirstModelIndex != -1) {
					for (Trait objTrait : this.lstTrials.get(intTrialIndex).getModels().get(intFirstModelIndex).getTraits()) {
						if (objTrait.getName().equals(objMapEntry.getKey())) {
							/////////////////////////////
							// The column "First Model"    
							/////////////////////////////
							objArrayRowData[12] = this.lstTrials.get(intTrialIndex).getModels().get(intFirstModelIndex).getName();
							//////////////////////////////
							// The column "FM Converged"    
							//////////////////////////////
							objArrayRowData[13] = this.translateBooleanValue(objTrait.getConverged());
							/////////////////////////////
							// The column "Bounded VCs"    
							/////////////////////////////
							objArrayRowData[14] = this.translateBooleanValue(objTrait.getBoundedVCs());
							break;
						}
					}
				}

				/////////////////////
				// The Second Model      
				/////////////////////
				if (intSecondModelIndex != -1) {
					for (Trait objTrait : this.lstTrials.get(intTrialIndex).getModels().get(intSecondModelIndex).getTraits()) {
						if (objTrait.getName().equals(objMapEntry.getKey())) {
							//////////////////////////////
							// The column "Second Model"    
							//////////////////////////////
							objArrayRowData[15] = this.lstTrials.get(intTrialIndex).getModels().get(intSecondModelIndex).getName();
							//////////////////////////////
							// The column "SM Converged"    
							//////////////////////////////
							objArrayRowData[16] = this.translateBooleanValue(objTrait.getConverged());
							break;
						}
					}
				}
				
				if ((intCurrentReportIndex != -1) && 
					(intPreviousReportIndex != -1)) {
					////////////////////////////////////////////////////////
					// The column "Correlation Of estimate (entrySummary)"   
					////////////////////////////////////////////////////////
					douEntryCorrelationEstimate = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getEntryEstimates().get(strTraitName), 
							                                                                               this.lstPreviousReports.get(intPreviousReportIndex).getEntryEstimates().get(strTraitName));
					objArrayRowData[17] = douEntryCorrelationEstimate;
					
					/////////////////////////////////////////////////////////
					// The column "Correlation Of coreCheck (entrySummary)"   
					/////////////////////////////////////////////////////////
					douEntryCorrelationCoreCheck = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getEntryCoreChecks().get(strTraitName),
					                                                                                        this.lstPreviousReports.get(intPreviousReportIndex).getEntryCoreChecks().get(strTraitName));
					objArrayRowData[18] = douEntryCorrelationCoreCheck;
										
					////////////////////////////////////////////////////
					// The column "Correlation Of rank (entrySummary)"     
					////////////////////////////////////////////////////
					douEntryCorrelationRank = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getEntryRanks().get(strTraitName),
					                                                                                   this.lstPreviousReports.get(intPreviousReportIndex).getEntryRanks().get(strTraitName));
					objArrayRowData[19] = douEntryCorrelationRank; 

					/////////////////////////////////////////////////////
					// The column "Correlation Of rawMean (exlSummary)"   
					/////////////////////////////////////////////////////
					douExlCorrelationRawMean = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getExlRawMeans().get(strTraitName),
					                                                                                    this.lstPreviousReports.get(intPreviousReportIndex).getExlRawMeans().get(strTraitName));
					objArrayRowData[20] = douExlCorrelationRawMean;
					
					///////////////////////////////////////////////////////
					// The column "Correlation Of coreCheck (exlSummary)"   
					///////////////////////////////////////////////////////
					douExlCorrelationCoreCheck = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getExlCoreChecks().get(strTraitName),
					                                                                                      this.lstPreviousReports.get(intPreviousReportIndex).getExlCoreChecks().get(strTraitName));
					objArrayRowData[21] = douExlCorrelationCoreCheck;
					
					/////////////////////////////////////////////////
					// The column "Correlation Of CAV (exlSummary)"   
					/////////////////////////////////////////////////
					douExlCorrelationCav = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getExlCavs().get(strTraitName),
					                                                                                this.lstPreviousReports.get(intPreviousReportIndex).getExlCavs().get(strTraitName));
					objArrayRowData[22] = douExlCorrelationCav;

					///////////////////////////////////////////////////////////
					// The column "Correlation Of estimate (locationSummary)"   
					///////////////////////////////////////////////////////////
					douLocCorrelationEstimate = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getLocEstimates().get(strTraitName),
					                                                                                     this.lstPreviousReports.get(intPreviousReportIndex).getLocEstimates().get(strTraitName));
					objArrayRowData[23] = douLocCorrelationEstimate;

					
					/////////////////////////////////////////////////////
					// The column "Correlation Of CV (locationSummary)"     
					/////////////////////////////////////////////////////
					douLocCorrelationCv = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getLocCvs().get(strTraitName),
					                                                                               this.lstPreviousReports.get(intPreviousReportIndex).getLocCvs().get(strTraitName));
					objArrayRowData[24] = douLocCorrelationCv;	

					//////////////////////////////////////////////////////////
					// The column "Correlation Of checkCV (locationSummary)"     
					//////////////////////////////////////////////////////////
					douLocCorrelationCheckCv = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getLocCheckCvs().get(strTraitName),
					                                                                                    this.lstPreviousReports.get(intPreviousReportIndex).getLocCheckCvs().get(strTraitName));
					objArrayRowData[25] = douLocCorrelationCheckCv;
					
					///////////////////////////////////////////////////////////////////
					// The column "Correlation Of rawCoreCheckMean (locationSummary)"       
					///////////////////////////////////////////////////////////////////
					douLocCorrelationRawCoreCheckMean = this.getDoublePearsonProductMomentCorrelationCoefficient(this.lstCurrentReports.get(intCurrentReportIndex).getLocRawCoreCheckMeans().get(strTraitName),
					                                                                                             this.lstPreviousReports.get(intPreviousReportIndex).getLocRawCoreCheckMeans().get(strTraitName));
					objArrayRowData[26] = douLocCorrelationRawCoreCheckMean;
				}
				
				///////////////////////////////
				// The column "Creation Time"  
				///////////////////////////////
				if (intCurrentReportIndex != -1) {
					objArrayRowData[27] = this.lstCurrentReports.get(intCurrentReportIndex).getCreationTime();
				}
					
				//////////////////////////////////////////
				// Writing the row data in the worksheet    
				//////////////////////////////////////////
				this.objReportWriter.writeRowData(objArrayRowData);
			}
			this.objReportWriter.closeSheet();
		}

		////////////////////////////////////////////////////////////////////////
		// Checking any trial with no asr data but still with a current report    
		////////////////////////////////////////////////////////////////////////
		objLogger.info("Generating a list of trials with no asr data and a report...");
		this.objReportWriter.createSheet("No Asr File Created",
                                         strArrayHeaders);
		for (Report objCurrentReport : this.lstCurrentReports) {
			if (this.lstTrials.indexOf(new Trial(objCurrentReport.getTrialName(), 
					                             null)) == -1) {
				objArrayRowData = new Object[strArrayHeaders.length];
				objArrayRowData[ 6] = objCurrentReport.getTrialName();
				this.objReportWriter.writeRowData(objArrayRowData);
			}
		}
		this.objReportWriter.closeSheet();
		
		this.saveAllProcessedSheetsData();
	}

	private boolean getBoundedC(String strInC) {
		if (strInC == null) { 
			return false; }
		
		return (!(strInC.equals("P")));
	}
	
	private String translateBooleanValue(boolean bolInValue) {
		if (bolInValue == true) {
			return "Yes";
		}
		else {
			return "No";
		}
	}

	private double getDoublePearsonProductMomentCorrelationCoefficient(Map<String, Double> mapInStringKeyDoubleX,
                                                                       Map<String, Double> mapInStringKeyDoubleY)
	{
		double douPearsonProductMomentCorrelationCoefficient;
		List<Double> lstDoubleX;
		List<Double> lstDoubleY;
		double[] douArrayX;
	    double[] douArrayY;

		douPearsonProductMomentCorrelationCoefficient = 0.0;
		if ((mapInStringKeyDoubleX != null) && 
		    (mapInStringKeyDoubleY != null))
		{
			lstDoubleX = new ArrayList<Double>();
			lstDoubleY = new ArrayList<Double>();
			for (String strKey : mapInStringKeyDoubleX.keySet()) {
				if (mapInStringKeyDoubleY.containsKey(strKey)) {
					lstDoubleX.add(mapInStringKeyDoubleX.get(strKey));
					lstDoubleY.add(mapInStringKeyDoubleY.get(strKey));
				}
			}
			if (1 < lstDoubleX.size()) {
				douArrayX = ArrayUtils.toPrimitive(lstDoubleX.toArray(new Double[lstDoubleX.size()]));
				douArrayY = ArrayUtils.toPrimitive(lstDoubleY.toArray(new Double[lstDoubleY.size()]));
				try {
					douPearsonProductMomentCorrelationCoefficient = new PearsonsCorrelation().correlation(douArrayX, 
							                                                                              douArrayY);
				}
				catch (IllegalArgumentException e) {
					this.objReportWriter.closeSheet();
					this.saveAllProcessedSheetsData();
					System.err.println("Exception in trying to make the Pearson's correlation coefficient");
					e.printStackTrace();
					objLogger.error("Validator.getPearsonProductMomentCorrelationCoefficient", 
					                e);
					throw new RuntimeException();
				}
			}
		}
		
		return douPearsonProductMomentCorrelationCoefficient;
	}	

	private void saveAllProcessedSheetsData() {
		//////////////////////////////////////////////
		// Writing all the the data in the .xls file    
		//////////////////////////////////////////////
		this.objReportWriter.close(System.getProperty("user.dir") + 
						           System.getProperty("file.separator") + 
	                               "report_" +
	                               this.objDataFormat.format(new Date()) + 
	                               ".xls");
	}
}
