package io;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.NoSuchFieldException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.apache.log4j.Logger;

public class EntrySummaryReader {

	static Logger objLogger = Logger.getLogger(EntrySummaryReader.class.getName());
	public static final String TAB = "\t";
	private Map<String, Integer> mapRecordsNumbers;
	private Map<String, Map<Integer, Double>> mapEstimates;
	private Map<String, Integer> mapRawCounts;
	private List<Map<String, String>> lstMapEntrySummaryData;
	
	public EntrySummaryReader(Path objInEntrySummaryFilePath) throws NoSuchFieldException {
		BufferedReader objBufferedReader;
		int intLineNumber;
		String strLine;
		String[] strArrayHeaders;
		ArrayList<String> lstHeaders;
		int intTraitNameColumnIndex;
		int intGenoIdColumnIndex;
		int intEstimateColumnIndex;
		int intRawCountColumnIndex;
		String[] strArrayLineParts;
		String strTraitName;
		Map<Integer, Double> mapEstimates;		
		Map<String, String> mapDataLine;
		int intArrayIndex;
		Map<Integer, Double> objTreeMap;
		
		this.mapRecordsNumbers =  new HashMap<String, Integer>();
		this.mapEstimates = new HashMap<String, Map<Integer, Double>>();
		this.mapRawCounts = new HashMap<String, Integer>();
		this.lstMapEntrySummaryData = new ArrayList<Map<String, String>>();
		objBufferedReader = null;
		intLineNumber = 0;
		strArrayHeaders = null;
		intTraitNameColumnIndex = -1;
		intGenoIdColumnIndex = -1;
		intEstimateColumnIndex = -1;
		intRawCountColumnIndex = -1;
		try {
			objBufferedReader = new BufferedReader(new FileReader(objInEntrySummaryFilePath.toFile()));
			while ((strLine = objBufferedReader.readLine()) != null) {
				intLineNumber++;
				////////////////
				// The headers  
				////////////////
				if (intLineNumber == 1) {
					strArrayHeaders = strLine.trim().split(TAB);
					lstHeaders = new ArrayList<String>(Arrays.asList(strArrayHeaders));
					//System.out.println("Headers: " + lstHeaders.toString());
					try {
						///////////////////
						// traitVatString 
						///////////////////
						if (!(lstHeaders.contains("traitVatString"))) {
							throw new NoSuchFieldException("No traitVatString column in " + 
						                                   objInEntrySummaryFilePath.toString());
						}
						else {
							intTraitNameColumnIndex = lstHeaders.indexOf("traitVatString");
						}

						///////////
						// genoId  
						///////////
						if (!(lstHeaders.contains("genoId"))) {
							throw new NoSuchFieldException("No genoId column in " + 
						                                   objInEntrySummaryFilePath.toString());
						}
						else {
							intGenoIdColumnIndex = lstHeaders.indexOf("genoId");
						}
						
						/////////////
						// estimate    
						/////////////
						if (!(lstHeaders.contains("estimate"))) {
							throw new NoSuchFieldException("No estimate column in " + 
	                                                       objInEntrySummaryFilePath.toString());
						}
						else {
							intEstimateColumnIndex = lstHeaders.indexOf("estimate");
						}
						
						/////////////
						// rawCount  
						/////////////
						if (!(lstHeaders.contains("rawCount"))) {
							throw new NoSuchFieldException("No rawCount column in " + 
	                                                       objInEntrySummaryFilePath.toString());
						}
						else {
							intRawCountColumnIndex = lstHeaders.indexOf("rawCount");
						}
					}
					catch (NoSuchFieldException e) {
						e.printStackTrace();
						objLogger.error("EntrySummaryReader.EntrySummaryReader", 
						                e);
						throw new RuntimeException();
					}
				}
				///////////////////
				// The data lines  
				///////////////////
				else {
					strArrayLineParts = strLine.split(TAB,
	                                                  strArrayHeaders.length);
					try {
						if (strArrayHeaders.length == strArrayLineParts.length) {
							strTraitName = strArrayLineParts[intTraitNameColumnIndex];
							
							///////////////////
							// Records Number  
							///////////////////
							if (this.mapRecordsNumbers.containsKey(strTraitName)) {
								this.mapRecordsNumbers.put(strTraitName, 
										                   (this.mapRecordsNumbers.get(strTraitName) + 1));
							}
							else {
								this.mapRecordsNumbers.put(strTraitName, 
						                                   1);
							}

							/////////////
							// Estimate   
							/////////////
							/////////////////////////////////////////////////////////////////////////////////
							// Note: There is sometimes not data in the estimate column for determined rows  
							/////////////////////////////////////////////////////////////////////////////////
							if (strArrayLineParts[intEstimateColumnIndex].equals("")) {
								System.err.println("No data in the estimate column in " + objInEntrySummaryFilePath.toString() + 
								                   " in the row #" + intLineNumber);
							}
							else {
								try {
									if (this.mapEstimates.containsKey(strTraitName)) {
										mapEstimates = this.mapEstimates.get(strTraitName);
									}
									else {
										mapEstimates = new HashMap<Integer, Double>();
									}
									mapEstimates.put(Integer.parseInt(strArrayLineParts[intGenoIdColumnIndex]), 
											         Double.parseDouble(strArrayLineParts[intEstimateColumnIndex])); 
									this.mapEstimates.put(strTraitName, 
								                      	  mapEstimates);
								}
								catch (NumberFormatException e) {
									e.printStackTrace();
									objLogger.error("EntrySummaryReader.EntrySummaryReader", 
				                                	e);
									throw new RuntimeException();
								}
							}

							/////////////
							// rawCount  
							/////////////
							if (strArrayLineParts[intRawCountColumnIndex].equals("")) {
								System.err.println("No data in the rawCount column in " + objInEntrySummaryFilePath.toString() + 
								                   " in the row #" + intLineNumber);
							}
							else {
								try {
									if (this.mapRawCounts.containsKey(strTraitName)) {
										this.mapRawCounts.put(strTraitName, 
												              this.mapRawCounts.get(strTraitName) +  Integer.parseInt(strArrayLineParts[intRawCountColumnIndex]));
									}
									else {
										this.mapRawCounts.put(strTraitName, 
												              Integer.parseInt(strArrayLineParts[intRawCountColumnIndex]));
									}
								}
								catch (NumberFormatException e) {
									e.printStackTrace();
									objLogger.error("EntrySummaryReader.EntrySummaryReader", 
				                                	e);
									throw new RuntimeException();
								}
							}
							
							//////////////
							// Data Line 
							//////////////
							mapDataLine = new HashMap<String, String>();
							for (intArrayIndex = 0;
								 intArrayIndex < strArrayLineParts.length;	
							     intArrayIndex++) {
								mapDataLine.put(strArrayHeaders[intArrayIndex], 
									            strArrayLineParts[intArrayIndex]);
							}
							this.lstMapEntrySummaryData.add(mapDataLine);
						}
						else {
							throw new NoSuchFieldException("Inconsistency in the headers and fields numbers in " + 
                                                           objInEntrySummaryFilePath.toString());
						}
					}
					catch (NoSuchFieldException e) {
						e.printStackTrace();
						objLogger.error("EntrySummaryReader.EntrySummaryReader", 
				                        e);
						throw new RuntimeException();
					}
				}
			}
		}
		catch (IOException e) {
			e.printStackTrace();
			objLogger.error("EntrySummaryReader.EntrySummaryReader", 
					        e);
			throw new RuntimeException();
		}
		finally {
			try {
				if (objBufferedReader != null) {
					objBufferedReader.close();
				}
			} 
			catch (IOException e) {
				e.printStackTrace();
				objLogger.error("EntrySummaryReader.EntrySummaryReader", 
				                e);
				throw new RuntimeException();
			}
		}
		
		//////////////////////////////////////////////////
		// Sorts each estimates map basing on the genoId  
		//////////////////////////////////////////////////
		for (String strKey : this.mapEstimates.keySet()) {
			mapEstimates = this.mapEstimates.get(strKey);
			objTreeMap = new TreeMap<Integer, Double>(mapEstimates);
			this.mapEstimates.put(strKey,
					              objTreeMap);
		}		
	}
	
	public Map<String, Integer> getRecordsNumbers() {
		return this.mapRecordsNumbers;
	}

	public Map<String, Map<Integer, Double>> getEstimates() {
		return this.mapEstimates;
	}

	public Map<String, Integer> getRawCounts() {
		return this.mapRawCounts;
	}
	
	public List<Map<String, String>> getData() {
		return this.lstMapEntrySummaryData;
	}	
}
