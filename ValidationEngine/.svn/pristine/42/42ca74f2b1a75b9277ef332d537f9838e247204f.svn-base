package data;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

///////////////////////////////////////////////////////////////
// The name identifier of the report object is the trial name  
///////////////////////////////////////////////////////////////
public class Report {

	static Logger objLogger = Logger.getLogger(Report.class.getName());
	public static final String NEWLINE = System.getProperty("line.separator");
	private String strName;
	private String strTimeStamp;
	private String strRegularExpression;
	private Pattern objPattern;
	private Map<String, Integer> mapLocationsNumbers;
	private Map<String, Integer> mapRecordsNumbers;
	private Map<String, Map<Integer, Double>> mapEntryEstimates;
	private Map<String, Integer> mapRawCounts;
	private Map<String, Map<String, Double>> mapExlRawMeans;
	private Map<String, Map<Integer, Double>> mapLocationEstimates;

	public Report(String strInName) {
		this.strName = strInName;
		this.strTimeStamp = "";
		///////////////////  
		// YYYYMMDDHHMMSS  
        ///////////////////
		this.strRegularExpression = "^[0-9]{14}$";
		this.objPattern = Pattern.compile(this.strRegularExpression);
		this.mapLocationsNumbers = new HashMap<String, Integer>();
		this.mapRecordsNumbers = new HashMap<String, Integer>();	
		this.mapEntryEstimates = new HashMap<String, Map<Integer, Double>> ();
		this.mapRawCounts = new HashMap<String, Integer>();
		this.mapExlRawMeans = new HashMap<String, Map<String, Double>>();
		this.mapLocationEstimates = new HashMap<String, Map<Integer, Double>>();
	}
	
	@Override
	public boolean equals(Object objIn) {
		if ((objIn != null) && 
			(objIn instanceof Report)) {
			return this.strName.equals(((Report)objIn).getName());
		}
		else {
			return false;
		}
	}
	
	public void setTimeStamp(String strInTimeStamp) {
		try {
			if (!(this.checkTimeStampFormat(strInTimeStamp))) {
				throw new Exception("Timestamp format incorrect: " + strInTimeStamp + 
				                    " when treating the report " + this.strName);
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			objLogger.error("Report.setTimeStamp", 
	                        e);
			throw new RuntimeException();
		}
		this.strTimeStamp = strInTimeStamp;
	}

	public void setLocationsNumbers(Map<String, Integer> mapInLocationsNumbers) {
		this.mapLocationsNumbers = mapInLocationsNumbers;
	}
	
	public void setRecordsNumbers(Map<String, Integer> mapInRecordsNumbers) {
		this.mapRecordsNumbers = mapInRecordsNumbers;
	}
	
	public void setEntryEstimates(Map<String, Map<Integer, Double>> mapInEntryEstimatesByTrait) {
		this.mapEntryEstimates = mapInEntryEstimatesByTrait;
	}
	
	public void setRawCounts(Map<String, Integer> mapInRawCountsByTrait) {
		this.mapRawCounts = mapInRawCountsByTrait; 
	}
	
	public void setExlRawMeans(Map<String, Map<String, Double>> mapInExlRawMeansByTrait) {
		this.mapExlRawMeans = mapInExlRawMeansByTrait;
	}

	public void setLocationEstimates(Map<String, Map<Integer, Double>> mapInLocationEstimatesByTrait) {
		this.mapLocationEstimates = mapInLocationEstimatesByTrait;
	}
	
	public String getName() {
		return this.strName;
	}
	
	public String getTimeStamp() {
		return this.strTimeStamp;
	}
	
	public Map<String, Integer> getLocationsNumbers() {
		return this.mapLocationsNumbers;	
	}
	
	public Map<String, Integer> getRecordsNumbers() {
		return this.mapRecordsNumbers;
	}

	public Map<String, Map<Integer, Double>> getEntryEstimates() {
		return this.mapEntryEstimates;
	}
	
	public Map<String, Integer> getRawCounts() {
		return this.mapRawCounts;
	}
	
	public Map<String, Map<String, Double>> getExlRawMeans() {
		return this.mapExlRawMeans;
	}
	
	public Map<String, Map<Integer, Double>> getLocationEstimates() {
		return this.mapLocationEstimates;
	}
	
	public boolean checkTimeStampFormat(String strInTimeStamp) {
		if (this.objPattern.matcher(strInTimeStamp).find()) {
			return true;
		}
		else {
			return false;
		}
	}

	public boolean isOlderThan(String strInTimeStamp) {
		try {
			if (this.strTimeStamp.equals("")) {
				throw new Exception("The timestamp attribute of this report is empty");
			}
		}
		catch (Exception e) {
			throw new RuntimeException();
		}
		
		return (this.strTimeStamp.compareTo(strInTimeStamp) < 0);
	}

	@Override 
	public String toString() {
		String strOutput;
		
		strOutput = "Name Report: " + this.strName + NEWLINE;
		strOutput = strOutput + "Timestamp: " + this.strTimeStamp + NEWLINE;
		strOutput = strOutput + "Locations Numbers: " + NEWLINE;
		for (Map.Entry<String, Integer> objEntry : this.mapLocationsNumbers.entrySet()) {
			strOutput = strOutput + "\t" + objEntry.getKey() + ": " + objEntry.getValue() + NEWLINE;
		}
		strOutput = strOutput + "Records Numbers: " + NEWLINE;
		for (Map.Entry<String, Integer> objEntry : this.mapRecordsNumbers.entrySet()) {
			strOutput = strOutput + "\t" + objEntry.getKey() + ": " + objEntry.getValue() + NEWLINE;
		}
		strOutput = strOutput + "Entry Estimates: " + NEWLINE;
		for (Map.Entry<String, Map<Integer, Double>> objEntry : this.mapEntryEstimates.entrySet()) {
			strOutput = strOutput + "\t" + objEntry.getKey() + ": " + objEntry.getValue() + NEWLINE;
		}
		strOutput = strOutput + "Raw Counts: " + NEWLINE;
		for (Map.Entry<String, Integer> objEntry : this.mapRawCounts.entrySet()) {
			strOutput = strOutput + "\t" + objEntry.getKey() + ": " + objEntry.getValue() + NEWLINE;
		}
		strOutput = strOutput + "Exl Raw Means: " + NEWLINE;
		for (Map.Entry<String, Map<String, Double>> objEntry : this.mapExlRawMeans.entrySet()) {
			strOutput = strOutput + "\t" + objEntry.getKey() + ": " + objEntry.getValue() + NEWLINE;
		}
		strOutput = strOutput + "Location Estimates: " + NEWLINE;
		for (Map.Entry<String, Map<Integer, Double>> objEntry : this.mapLocationEstimates.entrySet()) {
			strOutput = strOutput + "\t" + objEntry.getKey() + ": " + objEntry.getValue() + NEWLINE;
		}
		strOutput = strOutput + NEWLINE;
				
		return strOutput;
	} 
}